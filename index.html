<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Nancy Kansal</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="favicon.svg">
</head>

<body>
<h1>Nancy Kansal</h1>

<address><a href="https://www.niet.co.in/pdf/faculty/Faculty_List_IT.pdf">Assistant professor</a><br>
<!-- <a class="lab"</a>  -->
<br>Information Technology, </br>
School of Computer Science and Information Technology<br>
Noida Institute of Engineering and Technology<br>
Knowledge Part II, Gr. Noida, India.</address>

<aside>
<figure>
    <img src="https://github.com/AngelAngel1110/AngelAngel1110.github.io/blob/main/images/Mine.JPG" alt="Nancy Kansal">
    <figcaption>Nancy Kansal during her <em>graduation 2020</em></figcaption>
</figure>
</aside>
<!-- 
<p>My research is centered around novel directions for <em>high-performance large-scale data management</em> systems. My research has a strong <em>theoretical</em> component (e.g., lower bound results, finite model theory, dependency theory) and a strong <em>algorithmic</em> component (e.g., external-memory algorithms, distributed algorithms, join algorithms). Currently, my focus is on the development of <em>scalable resilient systems</em> that can manage data and processing complex transactions, while providing strong guarantees toward users in the presence of faulty behavior (e.g., hardware failures, software failures, and malicious attacks).
-->

<p>Previously, I was a Masters Scholar in the <a href="https://www.akgec.ac.in">Ajay Kumar Garg Engineering College, Ghaziabad</a> at the Computer Science and Engineering Department, where I worked on <em>Cross Domain Sentiment Analysis Thesis Project</em> under the supervision of Lipika Goel and <a href=" https://www.akgec.ac.in/cse-faculty/ ">Sonam Gupta</a>. Finally, I did my Bachelor in computer science and engineering at the <a href="https://www.rggi.edu.in">Radha Govind Group of Institions, Meerut</a>, where I studied various sujects like <em>Data Structures, Database Management Systems, Automata, Design and Analysis of Algorithms, Operating Systems, Computer Organization and Architecture, Digital Logic Design, Compiler Design, and more</em>.

<h2>Publications</h2>
<p><span class='local'>Jump to
        <a href='#pbook' class='also'>Books</a>,
        <a href='#pjournal' class='also'>Journal Papers</a>
       <!--  <a href='#pconference' class='also'>Conference Proceedings</a>,
        <a href='#ptdt' class='also'>Tutorials, Demos, and Talks</a>,
        <a href='#pthesis' class='also'>Theses</a></span>.<br>
-->
<h3 id='pbook'>Books</h3><ol start='1'><li class='ref' id='MC-2021'>2022. <div class='detail'><quote>Architecture, Security Vulnerabilities, and the Proposed Countermeasures in Agriculture-Internet-of-Things (AIoT) Systems</quote>. <span class='author'>Nancy Kansal, Bharat Bhushan, and Shubham Sharma</span>. <span class='year'>(2022)</span>. <span class='in'>In book: Internet of Things and Analytics for Agriculture, Volume 3 (pp.329-353)</span>. <span class='publisher'>Springer</span>. <span class='doi'>DOI: <a href='http://dx.doi.org/10.1007/978-981-16-6210-2_16'>10.1007/978-981-16-6210-2_16</a></span>. </div><details class='abstract' open><summary>Abstract</summary><blockquote class='abstract'><p>In recent years, along with the rise in the population, the demand for food has also increased which led to the need for industrialization as well as intensification of agricultural sector. The Internet-of-Things (IoT) has been a promising technology that offers extended solutions towards the development of agriculture. Various research institutions and scientific groups, as well as industries, are trying to cope with the challenges by delivering more and more IoT products for agricultural sector. In this paper, we aim to provide a survey of IoT systems, its enabling technologies, and communication technologies. Moreover, we provide insights into IoT enabled agricultural applications along with its architecture and research challenges. Finally, we discussed the security and privacy issues that occur in agriculture IoT along with some cybersecurity attacks.</p></blockquote></details></li></ol>

<h3 id='pjournal'>Journal Papers</h3><ol start='2'><li class='ref' id='JLAMP-2022'>SIS 2020. <div class='detail'>
    <quote>Cross-domain sentiment classification initiated with Polarity Detection Task</quote>. 
    <span class='author'>Nancy Kansal, Lipika Goel, and Sonam Gupta</span>.
    <span class='year'>(2020)</span>. <span class='in'>In: EAI Transactions on Scalable Information Systems</span>. 
    <span class='publisher'>EAI Transactions</span>. <span class='doi'>DOI: <a href='http://dx.doi.org/10.4108/eai.26-5-2020.165965'>10.4108/eai.26-5-2020.165965</a></span>. 
    <!-- <span class='also'>See also 
        <a class='also' href='#FoIKS-2018a'>FoIKS 2018a</a>, 
        <a class='also' href='#PhD-thesis'>PhD thesis</a></span>.
    </div><span class='resources'> <a class='acopy' href='files/jlamp2022_paper.pdf'>author copy</a>, <a class='asite' href='projects/bruteforce'>project page</a></span>. -->

    <details class='abstract' open><summary>Abstract</summary><blockquote class='abstract'><p>INTRODUCTION: The requirement of the labeled dataset in the source domain makes the Cross Domain Sentiment Classification (CDSC) task complicate in the situation when the dataset is labeled manually. </p>
        <p>OBJECTIVES: To overcome the dependency of CDSC tasks on manual labeling of the dataset by proposing a polarity detection task. </p>
        <p>METHODS: We have proposed the CDSC-PDT method that is the polarity Detection Task (PDT) followed by the CDSC task. The proposed PDT task extracts the polarity of reviews from the source domain using the contextual and relevancy information of words in documents and this automatic labeled dataset is further used to train classifiers to make the further classification. </p>
        <p>RESULTS: Proposed method is comparable to the traditional learning method giving the highest precision 85.7%. CONCLUSION: The proposed method does not need to manually label the documents in either of the domain (source or target), hence it overcomes the human intervention and is also time saving and cheap process, unlike traditional CDSC tasks.</p>
    </blockquote>
</details></li><li class='ref' id='IJAIML-202O'>IJAIML 2020. <div class='detail'>
    <quote>A Literature review on Cross Domain sentiment Analysis using Machine Learning</quote>. 
    <span class='author'>Nancy Kansal, Lipika Goel, and Sonam Gupta</span>. <span class='year'>(2020)</span>. 
    <span class='publisher'>IGI-Global</span>. <span class='doi'>DOI: <a href='http://dx.doi.org/10.4018/IJAIML.2020070103'>10.4018/IJAIML.2020070103</a></span>.
    <!-- <span class='in'>In: Proceedings of the VLDB Endowment, 14(11), 2230-2243</span>. <span class='publisher'>VLDB</span>. <span class='doi'>DOI: <a href='https://doi.org/10.14778/3476249.3476275'>10.14778/3476249.3476275</a></span>. 
</div><span class='resources'> <a class='acopy' href='files/vldb2021_paper.pdf'>author copy</a>, <a class='aslide' href='files/vldb2021_slides.pdf'>slides</a>, <a class='aposter' href='files/vldb2021_poster.pdf'>poster</a>, <a class='asite' href='projects/byshard'>project page</a></span>. <details class='embed'><summary>Video Presentation</summary><div class='iframe-container'><div><iframe title='video-player' src='https://player.vimeo.com/video/586599477/' frameborder='0' allowfullscreen></iframe></div> </div></details>-->
<details class='abstract' open><summary>Abstract</summary><blockquote class='abstract'>
    <p>Sentiment analysis is the field of NLP which analyzes the sentiments of text written by users on online sites in the form of reviews. These reviews may be either in the form of a word, sentence, document, or ratings. These reviews are used as datasets when applied to train a classifier. These datasets are applied in the annotated form with the positive, negative or neutral labels as an input to train the classifier. This trained classifier is used to test other reviews, either in the same or different domains to know like or dislike of the user for the related field. Various researches have been done in single and cross domain sentiment analysis. The new methods proposed are overcoming the previous ones but according to this survey, no methods best suit the proposed work. In this article, the authors review the methods and techniques that are given by various researchers in cross domain sentiment analysis and how those are compared with the pre-existing methods for the related work.</p>



<!-- </blockquote></details></li><li class='ref' id='CJ-2020'>CJ 2020. <div class='detail'><quote>From relation algebra to semi-join algebra: An approach to graph query optimization</quote>. <span class='author'>Jelle Hellings, Catherine L. Pilachowski, Dirk Van Gucht, Marc Gyssens, and Yuqing Wu</span>. <span class='year'>(2020)</span>. <span class='in'>In: The Computer Journal, 64(5), 789--811</span>. <span class='publisher'>Oxford University Press</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1093/comjnl/bxaa031'>10.1093/comjnl/bxaa031</a></span>. <span class='also'>See also <a class='also' href='#DBPL-2017'>DBPL 2017</a>, <a class='also' href='#PhD-thesis'>PhD thesis</a></span>.</div><span class='resources'> <a class='acopy' href='files/cj2020_paper.pdf'>author copy</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Many graph query languages rely on composition to navigate graphs and select nodes of interest, even though evaluating compositions of relations can be costly. Often, this need for composition can be reduced by rewriting towards queries using semi-joins instead, resulting in a significant reduction of the query evaluation cost. We study techniques to recognize and apply such rewritings. Concretely, we study the relationship between the expressive power of the relation algebras, which heavily rely on composition, and the semi-join algebras, which replace composition in favor of semi-joins. Our main result is that each fragment of the relation algebras where intersection and/or difference is only used on edges (and not on complex compositions) is expressively equivalent to a fragment of the semi-join algebras. This expressive equivalence holds for node queries evaluating to sets of nodes. For practical relevance, we exhibit constructive rules for rewriting relation algebra queries to semi-join algebra queries, and prove that they lead to only a well-bounded increase in the number of steps needed to evaluate the rewritten queries. In addition, on sibling-ordered trees, we establish new relationships among the expressive power of <em class='name'>Regular XPath</em>, <em class='name'>Conditional XPath</em>, FO-logic, and the semi-join algebra augmented with restricted fixpoint operators.</p></blockquote></details></li><li class='ref' id='VLDB-2020'>VLDB 2020. <div class='detail'><quote>ResilientDB: global scale resilient blockchain fabric</quote>. <span class='author'>Suyash Gupta, Sajjad Rahnama, Jelle Hellings, and Mohammad Sadoghi</span>. <span class='year'>(2020)</span>. <span class='in'>In: Proceedings of the VLDB Endowment, 13(6), 868-883</span>. <span class='publisher'>VLDB</span>. <span class='doi'>DOI: <a href='https://doi.org/10.14778/3380750.3380757'>10.14778/3380750.3380757</a></span>. <span class='also'>See also <a class='also' href='#FAB-2020'>FAB 2020</a></span>.</div><span class='resources'> <a class='acopy' href='files/vldb2020_paper.pdf'>author copy</a>, <a class='areport' href='https://arxiv.org/abs/2002.00160'>technical report</a>, <a class='avideo' href='https://www.youtube.com/watch?v=FL1KXEvR-84'>video by Suyash Gupta</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Recent developments in blockchain technology have inspired innovative new designs in resilient distributed and database systems. At their core, these blockchain applications typically use Byzantine fault-tolerant consensus protocols to maintain a common state across all replicas, even if some replicas are faulty or malicious. Unfortunately, existing consensus protocols are not designed to deal with <em>geo-scale deployments</em> in which many replicas spread across a geographically large area participate in consensus.</p><p>To address this, we present the Geo-Scale Byzantine Fault-Tolerant consensus protocol (<em class='name'>GeoBFT</em>). <em class='name'>GeoBFT</em> is designed for excellent scalability by using a topological-aware grouping of replicas in local clusters, by introducing parallelization of consensus at the local level, and by minimizing communication between clusters. To validate our vision of high-performance geo-scale resilient distributed systems, we implement <em class='name'>GeoBFT</em> in our efficient <em class='name'>ResilientDB</em> permissioned blockchain fabric. We show that <em class='name'>GeoBFT</em> is not only sound and  provides great scalability, but also outperforms state-of-the-art consensus protocols by a factor of six in geo-scale deployments.</p></blockquote></details></li><li class='ref' id='IS-2020'>IS 2020. <div class='detail'><quote>Comparing the expressiveness of downward fragments of the relation algebra with transitive closure on trees</quote>. <span class='author'>Jelle Hellings, Marc Gyssens, Yuqing Wu, Dirk Van Gucht, Jan Van den Bussche, Stijn Vansummeren, and George H. L. Fletcher</span>. <span class='year'>(2020)</span>. <span class='in'>In: Information Systems, 89</span>. <span class='publisher'>Elsevier</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1016/j.is.2019.101467'>10.1016/j.is.2019.101467</a></span>. <span class='also'>See also <a class='also' href='#DBPL-2015'>DBPL 2015</a>, <a class='also' href='#PhD-thesis'>PhD thesis</a></span>.</div><span class='resources'> <a class='acopy' href='files/is2019_paper.pdf'>author copy</a>, <a class='areport' href='https://arxiv.org/abs/1803.01390'>technical report</a>, <a class='asite' href='projects/bruteforce'>project page</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Motivated by the continuing interest in the tree data model, we study the expressive power of downward navigational query languages on trees and chains.  Basic navigational queries are built from the identity relation and edge relations using composition and union. We study the effects on relative expressiveness when we add transitive closure, projections, coprojections, intersection, and difference; this for boolean queries and path queries on labeled and unlabeled structures. In all cases, we present the complete Hasse diagram. In particular, we establish, for each query language fragment that we study on trees, whether it is closed under difference and intersection.</p></blockquote></details></li><li class='ref' id='AMAI-2019'>AMAI 2019. <div class='detail'><quote>First-order definable counting-only queries</quote>. <span class='author'>Jelle Hellings, Marc Gyssens, Dirk Van Gucht, and Yuqing Wu</span>. <span class='year'>(2019)</span>. <span class='in'>In: Annals of Mathematics and Artificial Intelligence, 87, 109-136</span>. <span class='publisher'>Springer</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1007/s10472-019-09652-8'>10.1007/s10472-019-09652-8</a></span>. <span class='also'>See also <a class='also' href='#FoIKS-2018b'>FoIKS 2018b</a></span>.</div><span class='resources'> <a class='acopy' href='files/amai2019_paper.pdf'>author copy</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Many data sources can be represented easily by collections of sets of objects. For several practical queries on such collections of sets of objects, the answer does not depend on the precise composition of these sets, but only on the <em>number</em> of sets to which each object belongs. This is the case <em class='math'>k = 1</em> for the more general situation where the query answer only depends on the number of sets to which each <em>collection</em> of at most <em class='math'>k</em> objects belongs. We call such queries <em class='math'>k</em>-counting-only. Here, we focus on <em class='math'>k</em>-<em class='name'>SyCALC</em>, i.e., <em class='math'>k</em>-counting-only queries that are first-order definable. As <em class='math'>k</em>-<em class='name'>SyCALC</em> is semantically defined, however, it is not surprising that it is already undecidable whether a first-order query is in <em class='math'>1</em>-<em class='name'>SyCALC</em>. Therefore, we introduce <em class='name'>SimpleCALC</em>-<em class='math'>k</em>, a syntactically defined (strict) fragment of <em class='math'>k</em>-<em class='name'>SyCALC</em>. It turns out that many practical queries in <em class='math'>k</em>-<em class='name'>SyCALC</em> can already be expressed in <em class='name'>SimpleCALC</em>-<em class='math'>k</em>. We also define the query language <em class='name'>GCount</em>-<em class='math'>k</em>, which expresses counting-only queries directly by using generalized counting terms, and show that this language is equivalent to <em class='name'>SimpleCALC</em>-<em class='math'>k</em>. We prove that the <em class='math'>k</em>-counting-only queries form a non-collapsing hierarchy: for every <em class='math'>k</em>, there exist (<em class='math'>k</em>+1)-counting-only queries that are not <em class='math'>k</em>-counting-only. This result specializes to both <em class='name'>SimpleCALC</em>-<em class='math'>k</em> and <em class='math'>k</em>-<em class='name'>SyCALC</em>. Finally, we establish a strong dichotomy between <em class='math'>1</em>-<em class='name'>SyCALC</em> and <em class='name'>SimpleCALC</em>-<em class='math'>k</em> on the one hand and <em class='math'>2</em>-<em class='name'>SyCALC</em> on the other hand by showing that satisfiability, validity, query containment, and query equivalence are decidable for the former two languages, but not for the latter one.</p></blockquote></details></li><li class='ref' id='JCSS-2019'>JCSS 2019. <div class='detail'><quote>Calculi for symmetric queries</quote>. <span class='author'>Marc Gyssens, Jelle Hellings, Jan Paredaens, Dirk Van Gucht, Jef Wijsen, Yuqing Wu</span>. <span class='year'>(2019)</span>. <span class='in'>In: Journal of Computer and System Sciences, 105, 54-86</span>. <span class='publisher'>Elsevier</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1016/j.jcss.2019.04.003'>10.1016/j.jcss.2019.04.003</a></span>. </div><span class='resources'> <a class='acopy' href='files/jcss2019_paper.pdf'>author copy</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p><em>Symmetric queries</em> are introduced as queries on a sequence of sets of objects the result of which does not depend on the order of the sets. An appropriate data model is proposed, and two query languages are introduced, <em class='name'>QuineCALC</em> and <em class='name'>SyCALC</em>. They are correlated with the symmetric Boolean functions of Quine, respectively symmetric relational functions. The former correlation yields an incidence-based normal form for <em class='name'>QuineCALC</em> queries. More generally, we propose <em>counting-only</em> queries as those <em class='name'>SyCALC</em> queries the result of which only depends on incidence information, and characterize them as quantified Boolean combinations of <em class='name'>QuineCALC</em> queries. A normal form is proposed for them too. It is shown that, while it is undecidable whether a <em class='name'>SyCALC</em> query is counting-only, it is decidable whether a counting-only query is a <em class='name'>QuineCALC</em> query. Finally, some classical decidability problems are considered which are shown to be undecidable for <em class='name'>SyCALC</em>, but decidable for <em class='name'>QuineCALC</em> and counting-only queries.</p></blockquote></details></li><li class='ref' id='AMAI-2016'>AMAI 2016. <div class='detail'><quote>Implication and axiomatization of functional and constant constraints</quote>. <span class='author'>Jelle Hellings, Marc Gyssens, Jan Paredaens, Yuqing Wu</span>. <span class='year'>(2016)</span>. <span class='in'>In: Annals of Mathematics and Artificial Intelligence, 76(3), 251-279</span>. <span class='publisher'>Springer</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1007/s10472-015-9473-7'>10.1007/s10472-015-9473-7</a></span>. <span class='also'>See also <a class='also' href='#FoIKS-2014'>FoIKS 2014</a></span>.</div><span class='resources'> <a class='acopy' href='files/amai2016_paper.pdf'>author copy</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Akhtar et al. introduced equality-generating constraints and functional constraints as a first step towards dependency-like integrity constraints for RDF data. Here, we focus on functional constraints. Since the usefulness of functional constraints is not limited to the RDF data model, we study the functional constraints in the more general setting of relations with arbitrary arity. We further introduce constant constraints and study the functional and constant constraints combined.</p><p>Our main results are sound and complete axiomatizations for the functional and constant constraints, both separately and combined. These axiomatizations are derived using the chase algorithm for equality-generating constraints. For derivations of constant constraints, we show how every chase step can be simulated by a bounded number of applications of inference rules. For derivations of functional constraints, we show that the chase algorithm can be normalized to a more specialized symmetry-preserving chase algorithm performing so-called symmetry-preserving steps. We then show how each symmetry-preserving step can be simulated by a bounded number of applications of inference rules. The axiomatization for functional constraints is in particular applicable to the RDF data model, solving a major open problem of Akhtar et al.</p></blockquote></details></li></ol><h3 id='pconference'>Conference Proceedings (peer-reviewed)</h3><ol start='10'><li class='ref' id='FoIKS-2022a'>FoIKS 2022a. <div class='detail'><quote>The fault-tolerant cluster-sending problem</quote>. <span class='author'>Jelle Hellings and Mohammad Sadoghi</span>. <span class='year'>(2022)</span>. <span class='in'>In: Foundations of Information and Knowledge Systems</span>. </div><span class='resources'><a class='acopy' href='files/foiks2022_1_paper.pdf'>author copy</a>, <a class='aslide' href='files/foiks2022_1_slides.pdf'>slides</a></span>. <details class='abstract' open><summary>Abstract</summary><blockquote class='abstract'><p>The emergence of blockchains is fueling the development of resilient data management systems that can deal with <em>Byzantine failures</em> due to crashes, bugs, or even malicious behavior. As traditional resilient systems lack the scalability required for modern data, several recent systems explored using <em>sharding</em>.  Enabling these sharded designs requires two basic primitives: a primitive to reliably make decisions within a cluster and a primitive to reliably communicate between clusters. Unfortunately, such communication has not yet been formally studied.</p><p>In this work, we improve on this situation by formalizing the <em>cluster-sending problem</em>: the problem of sending a message from one resilient system to another in a fault-tolerant manner. We also establish lower bounds on the complexity of cluster-sending under both crashes and Byzantine failures. Finally, we present <em>worst-case optimal</em> cluster-sending protocols that meet these lower bounds in practical settings. As such, our work provides a strong foundation for the future development of sharded resilient data management systems.</p></blockquote></details></li><li class='ref' id='FoIKS-2022b'>FoIKS 2022b. <div class='detail'><quote>Optimizing multiset relational algebra queries using weak-equivalent rewrite rules</quote>. <span class='author'>Jelle Hellings, Yuqing Wu, Dirk Van Gucht, and Marc Gyssens</span>. <span class='year'>(2022)</span>. <span class='in'>In: Foundations of Information and Knowledge Systems</span>. </div><span class='resources'> <a class='acopy' href='files/foiks2022_2_paper.pdf'>author copy</a>, <a class='aslide' href='files/foiks2022_2_slides.pdf'>slides</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Relational query languages rely heavily on costly join operations to combine tuples from multiple tables into a single resulting tuple. In many cases, the cost of query evaluation can be reduced by <em>manually optimizing</em> (parts of) queries to use cheaper semi-joins instead of joins. Unfortunately, existing database products can only apply such optimizations <em>automatically</em> in rather limited cases.</p><p>To improve on this situation, we propose a framework for automatic query optimization via <em>weak-equivalent rewrite rules</em> for a multiset relational algebra (that serves as a faithful formalization of core SQL). The weak-equivalent rewrite rules we propose aim at replacing joins by semi-joins. To further maximize their usability, these rewrite rules do so by only providing <em>weak guarantees</em> on the evaluation results of rewritten queries.  We show that, in the context of certain operators, these weak-equivalent rewrite rules still provide strong guarantees on the final evaluation results of the rewritten queries.</p></blockquote></details></li><li class='ref' id='EDBT-2021'>EDBT 2021. <div class='detail'><quote>Proof-of-Execution: Reaching consensus through fault-tolerant speculation</quote>. <span class='author'>Suyash Gupta, Sajjad Rahnama, Jelle Hellings, and Mohammad Sadoghi</span>. <span class='year'>(2021)</span>. <span class='in'>In: Proceedings of the 24th International Conference on Extending Database Technology (EDBT), 301-312</span>. <span class='publisher'>OpenProceedings.org</span>. <span class='doi'>DOI: <a href='https://doi.org/10.5441/002/edbt.2021.27'>10.5441/002/edbt.2021.27</a></span>. </div><span class='resources'> <a class='acopy' href='files/edbt2021_paper.pdf'>author copy</a>, <a class='avideo' href='https://www.youtube.com/watch?v=cwHP_e_NOKI'>video by Suyash Gupta</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Multi-party data management and blockchain systems require data sharing among participants. To provide resilient and consistent data sharing, transactions engines rely on Byzantine Fault-Tolerant consensus (<em class='name'>BFT</em>), which enables operations during failures and malicious behavior. Unfortunately, existing <em class='name'>BFT</em> protocols are unsuitable for high-throughput applications due to their high computational costs, high communication costs, high client latencies, and/or reliance on twin-paths and non-faulty clients.</p><p>In this paper, we present the <em>Proof-of-Execution consensus protocol</em> (<em class='name'>PoE</em>) that alleviates these challenges. At the core of <em class='name'>PoE</em> are <em>out-of-order</em> processing and <em>speculative execution</em>, which allow <em class='name'>PoE</em> to execute transactions before consensus is reached among the replicas. With these techniques, <em class='name'>PoE</em> manages to reduce the costs of <em class='name'>BFT</em> in normal cases, while guaranteeing reliable consensus for clients in all cases.  We envision the use of <em class='name'>PoE</em> in high-throughput multi-party data-management and blockchain systems. To validate this vision, we implement <em class='name'>PoE</em> in our efficient <em class='name'>ResilientDB</em> fabric and extensively evaluate <em class='name'>PoE</em> against several state-of-the-art <em class='name'>BFT</em> protocols. Our evaluation showcases that <em class='name'>PoE</em> achieves  up-to-80% higher throughputs than existing <em class='name'>BFT</em> protocols in the presence of failures.</p></blockquote></details></li><li class='ref' id='ICDE-2021'>ICDE 2021. <div class='detail'><quote>RCC: Resilient concurrent consensus for high-throughput secure transaction processing</quote>. <span class='author'>Suyash Gupta, Jelle Hellings, and Mohammad Sadoghi</span>. <span class='year'>(2021)</span>. <span class='in'>In: 2021 IEEE 37th International Conference on Data Engineering (ICDE), 1392-1403</span>. <span class='publisher'>IEEE</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1109/ICDE51399.2021.00124'>10.1109/ICDE51399.2021.00124</a></span>. </div><span class='resources'> <a class='acopy' href='files/icde2021_paper.pdf'>author copy</a>, <a class='avideo' href='https://www.youtube.com/watch?v=l15M1jyTyvo'>video by Suyash Gupta</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Recently, we saw the emergence of consensus-based database systems that promise resilience against failures, strong data provenance, and federated data management. Typically, these fully-replicated systems are operated on top of a primary-backup consensus protocol, which limits the throughput of these systems to the capabilities of a single replica (the primary).</p><p>To push throughput beyond this single-replica limit, we propose <em>concurrent consensus</em>. In concurrent consensus, replicas independently propose transactions, thereby reducing the influence of any single replica on performance. To put this idea in practice, we propose our <em class='name'>RCC</em> paradigm that can turn any primary-backup consensus protocol into a <em>concurrent consensus protocol</em> by running many consensus instances concurrently. <em class='name'>RCC</em> is designed with performance in mind and requires minimal coordination between instances. Furthermore, <em class='name'>RCC</em> also promises increased resilience against failures. We put the design of <em class='name'>RCC</em> to the test by implementing it in <em class='name'>ResilientDB</em>, our high-performance resilient blockchain fabric, and comparing it with state-of-the-art primary-backup consensus protocols. Our experiments show that <em class='name'>RCC</em> achieves up to 2.75 times higher throughput than other consensus protocols and can be scaled to 91 replicas.</p></blockquote></details></li><li class='ref' id='TIME-2020'>TIME 2020. <div class='detail'><quote>Stab-Forests: Dynamic Data Structures for Efficient Temporal Query Processing</quote>. <span class='author'>Jelle Hellings and Yuqing Wu</span>. <span class='year'>(2020)</span>. <span class='in'>In: 27th International Symposium on Temporal Representation and Reasoning (TIME 2020), 18:1-18:19</span>. <span class='publisher'>Schloss Dagstuhl</span>. <span class='doi'>DOI: <a href='https://doi.org/10.4230/LIPIcs.TIME.2020.18'>10.4230/LIPIcs.TIME.2020.18</a></span>. </div><span class='resources'> <a class='acopy' href='files/time2020_paper.pdf'>author copy</a>, <a class='aslide' href='files/time2020_slides.pdf'>slides</a>, <a class='asite' href='projects/skipjoin'>project page</a></span>. <details class='embed'><summary>Video Presentation</summary><div class='iframe-container'><div><iframe title='video-player' src='https://www.youtube.com/embed/r67wjIL3izo/' frameborder='0' allowfullscreen></iframe></div></div></details><details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Many sources of data have temporal start and end attributes or are created in a time-ordered manner. Hence, it is only natural to consider joining datasets based on these temporal attributes. To do so efficiently, several internal-memory temporal join algorithms have recently been proposed. Unfortunately, these join algorithms are designed to join entire datasets and cannot efficiently join skewed datasets in which only few events participate in the join result.</p><p>To support high-performance internal-memory temporal joins of skewed datasets, we propose the <em>skip-join algorithm</em>, which operates on <em>stab-forests</em>.  The stab-forest is a novel dynamic data structure for indexing temporal data that allows efficient updates when events are appended in a time-based order. Our stab-forests efficiently support not only traditional temporal stab-queries, but also more general <em>multi-stab-queries</em>. We conducted an experimental evaluation to compare the skip-join algorithm with state-of-the-art techniques using real-world datasets. We observed that the skip-join algorithm outperforms other techniques by an order of magnitude when joining skewed datasets and delivers comparable performance to other techniques on non-skewed datasets.</p></blockquote></details></li><li class='ref' id='LSGDA-2020'>LSGDA 2020. <div class='detail'><quote>Explaining results of path queries on graphs</quote>. <span class='author'>Jelle Hellings</span>. <span class='year'>(2020)</span>. <span class='in'>In: Software Foundations for Data Interoperability and Large Scale Graph Data Analytics, 84-98</span>. <span class='publisher'>Springer</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1007/978-3-030-61133-0_7'>10.1007/978-3-030-61133-0_7</a></span>. </div><span class='resources'> <a class='acopy' href='files/lsgda2020_paper.pdf'>author copy</a>, <a class='areport' href='https://arxiv.org/abs/1502.02242'>technical report</a>, <a class='aslide' href='files/lsgda2020_slides.pdf'>slides</a>, <a class='asite' href='projects/cfpqpaths'>project page</a></span>. <details class='embed'><summary>Video Presentation</summary><div class='iframe-container'><div><iframe title='video-player' src='https://player.vimeo.com/video/586602658/' frameborder='0' allowfullscreen></iframe></div></div></details><details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Many graph query languages use, at their core, path queries that yield node pairs that are connected by a path of interest. For the end-user, such node pairs only give limited insight as to <em>why</em> this query result is obtained, as the pair does not directly identify the underlying path of interest. To address this limitation of path queries, we propose the <em>single-path semantics</em>, which evaluates path queries to, for each node pair <em class='math'>(m,n)</em>, a single path from <em class='math'>m</em> to <em class='math'>n</em> satisfying the conditions of the query. To put our proposal in practice, we provide an efficient algorithm for evaluating <em>context-free path queries</em>, a particular powerful type of path queries, using the single-path semantics. Additionally, we perform a short evaluation of our techniques that shows that the single-path semantics is practically feasible, even when query results grow large.</p></blockquote></details></li><li class='ref' id='ICDT-2020'>ICDT 2020. <div class='detail'><quote>Coordination-free Byzantine replication with minimal communication costs</quote>. <span class='author'>Jelle Hellings and Mohammad Sadoghi</span>. <span class='year'>(2020)</span>. <span class='in'>In: 23rd International Conference on Database Theory (ICDT 2020), 17:1-17:20</span>. <span class='publisher'>Schloss Dagstuhl</span>. <span class='doi'>DOI: <a href='https://doi.org/10.4230/LIPIcs.ICDT.2020.17'>10.4230/LIPIcs.ICDT.2020.17</a></span>. </div><span class='resources'> <a class='acopy' href='files/icdt2020_paper.pdf'>author copy</a>, <a class='aslide' href='files/icdt2020_slides.pdf'>slides</a>, <a class='avideo' href='https://doi.org/10.5446/46834'>video</a></span>. <details class='embed'><summary>Video Presentation</summary><div class='iframe-container'><div><iframe title='video-player' src='https://player.vimeo.com/video/586605855/' frameborder='0' allowfullscreen></iframe></div></div></details><details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>State-of-the-art fault-tolerant and federated data management systems rely on fully-replicated designs in which all participants have equivalent roles. Consequently, these systems have only limited scalability and are ill-suited for high-performance data management. As an alternative, we propose a hierarchical design in which a <em>Byzantine cluster</em> manages data, while an arbitrary number of <em>learners</em> can reliable learn these updates and use the corresponding data.</p><p>To realize our design, we propose the <em>delayed-replication algorithm</em>, an efficient solution to the <em>Byzantine learner problem</em> that is central to our design. The delayed-replication algorithm is coordination-free, scalable, and has minimal communication cost for all participants involved. In doing so, the delayed-broadcast algorithm opens the door to new high-performance fault-tolerant and federated data management systems. To illustrate this, we show that the delayed-replication algorithm is not only useful to support specialized learners, but can also be used to reduce the overall communication cost of permissioned blockchains and to improve their storage scalability.</p></blockquote></details></li><li class='ref' id='DISC-2019a'>DISC 2019a. <div class='detail'><quote>Brief announcement: The fault-tolerant cluster-sending problem</quote>. <span class='author'>Jelle Hellings and Mohammad Sadoghi</span>. <span class='year'>(2019)</span>. <span class='in'>In: 33rd International Symposium on Distributed Computing (DISC 2019), 45:1-45:3</span>. <span class='publisher'>Schloss Dagstuhl</span>. <span class='doi'>DOI: <a href='https://doi.org/10.4230/LIPIcs.DISC.2019.45'>10.4230/LIPIcs.DISC.2019.45</a></span>. </div><span class='resources'> <a class='acopy' href='files/disc2019_1_paper.pdf'>author copy</a>, <a class='areport' href='https://arxiv.org/abs/1908.01455'>technical report</a>, <a class='aslide' href='files/disc2019_1_slides.pdf'>slides</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>The development of fault-tolerant distributed systems that can tolerate Byzantine behavior has traditionally been focused on consensus protocols, which support fully-replicated designs. For the development of more sophisticated high-performance Byzantine distributed systems, more specialized fault-tolerant communication primitives are necessary, however.</p><p>In this brief announcement, we identify the <em>cluster-sending problem</em>--the problem of sending a message from one Byzantine cluster to another Byzantine cluster in a reliable manner--as such an essential communication primitive. We not only formalize this fundamental problem, but also establish lower bounds on the complexity of this problem under crash failures and Byzantine failures. Furthermore, we develop practical cluster-sending protocols that meet these lower bounds and, hence, have optimal complexity. As such, our work provides a strong foundation for the further exploration of novel designs that address challenges encountered in fault-tolerant distributed systems.</p></blockquote></details></li><li class='ref' id='DISC-2019b'>DISC 2019b. <div class='detail'><quote>Brief announcement: Revisiting consensus protocols through wait-free parallelization</quote>. <span class='author'>Suyash Gupta, Jelle Hellings, and Mohammad Sadoghi</span>. <span class='year'>(2019)</span>. <span class='in'>In: 33rd International Symposium on Distributed Computing (DISC 2019), 44:1-44:3</span>. <span class='publisher'>Schloss Dagstuhl</span>. <span class='doi'>DOI: <a href='https://doi.org/10.4230/LIPIcs.DISC.2019.44'>10.4230/LIPIcs.DISC.2019.44</a></span>. <span class='also'>See also <a class='also' href='#ICDE-2021'>ICDE 2021</a></span>.</div><span class='resources'> <a class='acopy' href='files/disc2019_2_paper.pdf'>author copy</a>, <a class='areport' href='https://arxiv.org/abs/1908.01458'>technical report</a>, <a class='aslide' href='files/disc2019_2_slides.pdf'>slides</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>In this brief announcement, we propose a <em>protocol-agnostic</em> approach to improve the design of primary-backup consensus protocols. At the core of our approach is a novel wait-free design of running several instances of the underlying consensus protocol <em>in parallel</em>. To yield a high-performance parallelized design, we present coordination-free techniques to order operations across parallel instances, deal with instance failures, and assign clients to specific instances. Consequently, the design we present is able to reduce the load on individual instances and primaries, while also reducing the adverse effects of any malicious replicas. Our design is fine-tuned such that the instances coordinated by non-faulty replicas are <em>wait-free</em>: they can continuously make consensus decisions, independent of the behavior of any other instances.</p></blockquote></details></li><li class='ref' id='FoIKS-2018a'>FoIKS 2018a. <div class='detail'><quote>The power of tarski's relation algebra on trees</quote>. <span class='author'>Jelle Hellings, Yuqing Wu, Marc Gyssens, and Dirk Van Gucht</span>. <span class='year'>(2018)</span>. <span class='in'>In: Foundations of Information and Knowledge Systems, 244-264</span>. <span class='publisher'>Springer</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1007/978-3-319-90050-6_14'>10.1007/978-3-319-90050-6_14</a></span>. <span class='also'>See also <a class='also' href='#JLAMP-2022'>JLAMP 2022</a>, <a class='also' href='#PhD-thesis'>PhD thesis</a></span>.</div><span class='resources'> <a class='acopy' href='files/foiks2018_1_paper.pdf'>author copy</a>, <a class='aslide' href='files/foiks2018_1_slides.pdf'>slides</a>, <a class='asite' href='projects/bruteforce'>project page</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Fragments of Tarski's relation algebra form the basis of many versatile graph and tree query languages including the regular path queries, <em class='name'>XPath</em>, and <em class='name'>SPARQL</em>. Surprisingly, however, a systematic study of the relative expressive power of relation algebra fragments on trees has not yet been undertaken. Our approach is to start from a basic fragment which only allows composition and union. We then study how the expressive power of the query language changes if we add diversity, converse, projections, coprojections, intersections, and/or difference, both for path queries and Boolean queries. For path queries, we found that adding intersection and difference yields more expressive power for some fragments, while adding one of the other operators always yields more expressive power. For Boolean queries, we obtain a similar picture for the relative expressive power, except for a few fragments where adding converse or projection yields no more expressive power. One challenging problem remains open, however, for both path and Boolean queries: does adding difference yields more expressive power to fragments containing at least diversity, coprojections, and intersection?</p></blockquote></details></li><li class='ref' id='FoIKS-2018b'>FoIKS 2018b. <div class='detail'><quote>First-order definable counting-only queries</quote>. <span class='author'>Jelle Hellings, Marc Gyssens, Dirk Van Gucht, and Yuqing Wu</span>. <span class='year'>(2018)</span>. <span class='in'>In: Foundations of Information and Knowledge Systems, 225-243</span>. <span class='publisher'>Springer</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1007/978-3-319-90050-6_13'>10.1007/978-3-319-90050-6_13</a></span>. <span class='also'>See also <a class='also' href='#AMAI-2019'>AMAI 2019</a></span>.</div><span class='resources'> <a class='acopy' href='files/foiks2018_2_paper.pdf'>author copy</a>, <a class='aslide' href='files/foiks2018_2_slides.pdf'>slides</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>For several practical queries on bags of sets of objects, the answer does not depend on the precise composition of these sets, but only on the <em>number</em> of sets to which each object belongs. This is the case <em class='math'>k</em>=$1$ for the more general situation where the query answer only depends on the number of sets to which each <em>group</em> of at most <em class='math'>k</em> objects belongs. We call such queries <em class='math'>k</em>-counting-only. Here, we focus on <em class='math'>k</em>-<em class='name'>SyCALC</em>, <em class='math'>k</em>-counting-only queries that are first-order definable. As <em class='math'>k</em>-<em class='name'>SyCALC</em> is semantically defined, however, it is not surprising that it is already undecidable whether a first-order query is in <em class='math'>1</em>-<em class='name'>SyCALC</em>. Therefore, we introduce <em class='name'>SimpleCALC</em>-<em class='math'>k</em>, a syntactically defined (strict) fragment of <em class='math'>k</em>-<em class='name'>SyCALC</em>. It turns out that many practical queries in <em class='math'>k</em>-<em class='name'>SyCALC</em> can already be expressed in <em class='name'>SimpleCALC</em>-<em class='math'>k</em>. We prove that the <em class='math'>k</em>-counting-only queries form a non-collapsing hierarchy: for every <em class='math'>k</em>, there exist (<em class='math'>k</em>+1)-counting-only queries that are not <em class='math'>k</em>-counting-only. This result specializes to both <em class='name'>SimpleCALC</em>-<em class='math'>k</em> and <em class='math'>k</em>-<em class='name'>SyCALC</em>. Finally, we establish a strong dichotomy between <em class='math'>1</em>-<em class='name'>SyCALC</em> and <em class='name'>SimpleCALC</em>-<em class='math'>k</em> on the one hand and <em class='math'>2</em>-<em class='name'>SyCALC</em> on the other hand by showing that satisfiability, validity, query containment, and query equivalence are decidable for the former two languages, but not for the latter one.</p></blockquote></details></li><li class='ref' id='DBPL-2017'>DBPL 2017. <div class='detail'><quote>From relation algebra to semi-join algebra: An approach for graph query optimization</quote>. <span class='author'>Jelle Hellings, Catherine L. Pilachowski, Dirk Van Gucht, Marc Gyssens, and Yuqing Wu</span>. <span class='year'>(2017)</span>. <span class='in'>In: Proceedings of The 16th International Symposium on Database Programming Languages, 5:1-5:10</span>. <span class='publisher'>ACM</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1145/3122831.3122833'>10.1145/3122831.3122833</a></span>. <span class='also'>See also <a class='also' href='#CJ-2020'>CJ 2020</a>, <a class='also' href='#PhD-thesis'>PhD thesis</a></span>.</div><span class='resources'> <a class='acopy' href='files/dbpl2017_paper.pdf'>author copy</a>, <a class='aslide' href='files/dbpl2017_slides.pdf'>slides</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Many graph query languages rely on the composition operator to navigate graphs and select nodes of interests, even though evaluating compositions of relations can be costly. Often, this need for composition can be reduced by rewriting towards queries that use semi-joins instead. In this way, the cost of evaluating queries can be significantly reduced.</p><p>We study techniques to recognize and apply such rewritings. Concretely, we study the relationship between the expressive power of the relation algebras, that heavily rely on composition, and the semi-join algebras, that replace the composition operator in favor of the semi-join operators.</p><p>As our main result, we show that each fragment of the relation algebras where intersection and/or difference is only used on edges (and not on complex compositions) is expressively equivalent to a fragment of the semi-join algebras. This expressive equivalence holds for node queries that evaluate to sets of nodes. For practical relevance, we exhibit constructive steps for rewriting relation algebra queries to semi-join algebra queries, and prove that these steps lead to only a well-bounded increase in the number of steps needed to evaluate the rewritten queries.</p><p>In addition, on node-labeled graphs that are sibling-ordered trees, we establish new relationships among the expressive power of <em class='name'>Regular XPath</em>, <em class='name'>Conditional XPath</em>, FO-logic, and the semi-join algebra augmented with restricted fixpoint operators.</p></blockquote></details></li><li class='ref' id='DBPL-2015'>DBPL 2015. <div class='detail'><quote>Relative expressive power of downward fragments of navigational query languages on trees and chains</quote>. <span class='author'>Jelle Hellings, Marc Gyssens, Yuqing Wu, Dirk Van Gucht, Jan Van den Bussche, Stijn Vansummeren, and George H. L. Fletcher</span>. <span class='year'>(2015)</span>. <span class='in'>In: Proceedings of the 15th Symposium on Database Programming Languages, 59-68</span>. <span class='publisher'>ACM</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1145/2815072.2815081'>10.1145/2815072.2815081</a></span>. <span class='also'>See also <a class='also' href='#IS-2020'>IS 2020</a>, <a class='also' href='#PhD-thesis'>PhD thesis</a></span>.</div><span class='resources'> <a class='acopy' href='files/dbpl2015_paper.pdf'>author copy</a>, <a class='aslide' href='files/dbpl2015_slides.pdf'>slides</a>, <a class='asite' href='projects/bruteforce'>project page</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Motivated by the continuing interest in the tree data model, we study the expressive power of downward fragments of navigational query languages on trees.  The basic navigational query language we consider expresses queries by building binary relations from the edge relations and the identity relation, using composition and union. We study the effects on the expressive power when we add transitive closure, projections, coprojections, intersection, and difference. We study expressiveness at the level of boolean queries and path queries, on labeled and unlabeled trees, and on labeled and unlabeled chains. In all these cases, we are able to present the complete Hasse diagram of relative expressiveness.  In particular, we were able to decide, for each fragment of the navigational query languages that we study, whether it is closed under difference and intersection when applied on trees.</p></blockquote></details></li><li class='ref' id='ICDT-2014'>ICDT 2014. <div class='detail'><quote>Conjunctive context-free path queries</quote>. <span class='author'>Jelle Hellings</span>. <span class='year'>(2014)</span>. <span class='in'>In: Proceedings of the 17th International Conference on Database Theory (ICDT), 119-130</span>. <span class='publisher'>OpenProceedings.org</span>. <span class='doi'>DOI: <a href='https://doi.org/10.5441/002/icdt.2014.15'>10.5441/002/icdt.2014.15</a></span>. </div><span class='resources'> <a class='acopy' href='files/icdt2014_paper.pdf'>author copy</a>, <a class='aslide' href='files/icdt2014_slides.pdf'>slides</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>In graph query languages, regular expressions are commonly used to specify the labeling of paths. A natural step in increasing the expressive power of these query languages is replacing regular expressions by context-free grammars. With the Conjunctive Context-Free Path Queries (<em class='name'>CCFPQ</em>) we introduce such a language based on the well-known Conjunctive Regular Path Queries (<em class='name'>CRPQ</em>).</p><p>First, we show that query evaluation of <em class='name'>CCFPQ</em> has polynomial time data complexity. Secondly, we look at the generalization of regular expressions, as used in <em class='name'>CRPQ</em>, to regular relations and show how similar generalizations can be applied to context-free grammars, as used in <em class='name'>CCFPQ</em>. Thirdly, we investigate the relations between the expressive power of <em class='name'>CRPQ</em>, <em class='name'>CCFPQ</em>, and their generalizations. In several cases we show that replacing regular expressions by context-free grammars does increase expressive power. Finally, we look at including context-free grammars in more powerful logics than conjunctive queries. We do so by adding negation and provide expressivity relations between the obtained languages.</p></blockquote></details></li><li class='ref' id='FoIKS-2014'>FoIKS 2014. <div class='detail'><quote>Implication and axiomatization of functional constraints on patterns with an application to the RDF data model</quote>. <span class='author'>Jelle Hellings, Marc Gyssens, Jan Paredaens, and Yuqing Wu</span>. <span class='year'>(2014)</span>. <span class='in'>In: Foundations of Information and Knowledge Systems, 250-269</span>. <span class='publisher'>Springer</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1007/978-3-319-04939-7_12'>10.1007/978-3-319-04939-7_12</a></span>. <span class='also'>See also <a class='also' href='#AMAI-2016'>AMAI 2016</a></span>.</div><span class='resources'> <a class='acopy' href='files/foiks2014_paper.pdf'>author copy</a>, <a class='aslide' href='files/foiks2014_slides.pdf'>slides</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Akhtar et al. introduced equality-generating constraints and functional constraints as an initial step towards dependency-like integrity constraints for RDF data. Here, we focus on functional constraints. The usefulness of functional constraints is not limited to the RDF data model. Therefore, we study the functional constraints in the more general setting of relations with arbitrary arity. We show that a chase algorithm for functional constraints can be normalized to a more specialized <em>symmetry-preserving chase</em> algorithm. This symmetry-preserving chase algorithm is subsequently used to construct a sound and complete axiomatization for the functional constraints. This axiomatization is in particular applicable in the RDF data model, solving a major open problem of Akhtar et al.</p></blockquote></details></li><li class='ref' id='ICDT-2013'>ICDT 2013. <div class='detail'><quote>Walk logic as a framework for path query languages on graph databases</quote>. <span class='author'>Jelle Hellings, Bart Kuijpers, Jan Van den Bussche, and Xiaowang Zhang</span>. <span class='year'>(2013)</span>. <span class='in'>In: Proceedings of the 16th International Conference on Database Theory, 117-128</span>. <span class='publisher'>ACM</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1145/2448496.2448512'>10.1145/2448496.2448512</a></span>. </div><span class='resources'> <a class='acopy' href='files/icdt2013_paper.pdf'>author copy</a>, <a class='aslide' href='files/icdt2013_slides.pdf'>slides</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Motivated by the current interest in languages for expressing path queries to graph databases, this paper proposes to investigate Walk Logic (<em class='name'>WL</em>): the extension of first-order logic on finite graphs with the possibility to explicitly quantify over walks.  <em class='name'>WL</em> can serve as a unifying framework for path query languages.  To support this claim, <em class='name'>WL</em> is compared in expressive power with various established query languages for graphs, such as first-order logic extended with reachability; the monadic second-order logic of graphs; hybrid computation tree logic; and regular path queries.  <em class='name'>WL</em> also serves as a framework to investigate the following natural questions: Is quantifying over walks more powerful than quantifying over paths (walks without repeating nodes) only?  Is quantifying over infinite walks more powerful than quantifying over finite walks only?  <em class='name'>WL</em> model checking is decidable, but determining the precise complexity remains an open problem.</p></blockquote></details></li><li class='ref' id='SIGMOD-2012'>SIGMOD 2012. <div class='detail'><quote>Efficient external-memory bisimulation on DAGs</quote>. <span class='author'>Jelle Hellings, George H.L. Fletcher, and Herman Haverkort</span>. <span class='year'>(2012)</span>. <span class='in'>In: Proceedings of the 2012 ACM SIGMOD International Conference on Management of Data, 553-564</span>. <span class='publisher'>ACM</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1145/2213836.2213899'>10.1145/2213836.2213899</a></span>. <span class='also'>See also <a class='also' href='#DBDBD-2011'>DBDBD 2011</a>, <a class='also' href='#Master-thesis'>Master thesis</a></span>.</div><span class='resources'> <a class='acopy' href='files/sigmod2012_paper.pdf'>author copy</a>, <a class='aslide' href='files/sigmod2012_slides.pdf'>slides</a>, <a class='asite' href='projects/exbisim'>project page</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>In this paper we introduce the first efficient external-memory algorithm to compute the bisimilarity equivalence classes of a directed acyclic graph (DAG). DAGs are commonly used to model data in a wide variety of practical applications, ranging from XML documents and data provenance models, to web taxonomies and scientific workflows.   In the study of efficient reasoning over massive graphs, the notion of node bisimilarity plays a central role.  For example, grouping together bisimilar nodes in an XML data set is the first step in many sophisticated approaches to building indexing data structures for efficient <em class='name'>XPath</em> query evaluation.    To date, however, only internal-memory bisimulation algorithms have been investigated.   As the size of real-world DAG data sets often exceeds available main memory, storage in external memory becomes necessary.  Hence, there is a practical need for an efficient approach to computing bisimulation in external memory.</p><p>Our general algorithm has a worst-case  IO-complexity of <em class='math'>O(Sort(|N| + |E|))</em>, where <em class='math'>|N|</em> and <em class='math'>|E|</em> are the numbers of nodes and edges, resp., in the data graph and <em class='math'>Sort(n)</em> is the number of accesses to external memory needed to sort an input of size <em class='math'>n</em>.  We also study specializations of this algorithm to common variations of bisimulation for tree-structured <em class='name'>XML</em> data sets.  We empirically verify efficient performance of the algorithms on graphs and <em class='name'>XML</em> documents having billions of nodes and edges, and find that the algorithms can process such graphs efficiently even when very limited internal memory is available. The proposed algorithms are simple enough for practical implementation and use, and open the door for further study of external-memory bisimulation algorithms.  To this end, the full open-source <em class='name'>C++</em> implementation has been made freely available.</p></blockquote></details></li></ol><h3 id='ptdt'>Tutorials, Demos, and Talks</h3><ol start='27'><li class='ref' id='ConsensusDays-21'>ConsensusDays 21. <div class='detail'><quote>Efficient fault-tolerant cluster-sending: Reliable and efficient communication between Byzantine fault-tolerant clusters</quote>. <span class='author'>Jelle Hellings and Mohammad Sadoghi</span>. <span class='year'>(2021)</span>. </div><span class='resources'> <a class='acopy' href='files/conday2021_abstract.pdf'>abstract</a>, <a class='aslide' href='files/conday2021_slides.pdf'>slides</a></span>. <details class='abstract' open><summary>Abstract</summary><blockquote class='abstract'><p>Traditional resilient systems operate on fully-replicated fault-tolerant clusters, which limits their scalability and performance. One way to make the step towards resilient high-performance systems that can deal with huge workloads, is by enabling independent fault-tolerant clusters to efficiently communicate and cooperate with each other, as this also enables the usage of high-performance techniques such as sharding and parallel processing.</p><p>To enable such efficient communication, we identify the <em>cluster-sending problem</em>: the problem of sending a message from one Byzantine cluster to another Byzantine cluster in a reliable manner, an essential communication primitive. We not only formalize this fundamental problem, but also establish lower bounds on the complexity of this problem under crash failures and Byzantine failures. Furthermore, we develop practical cluster-sending protocols that meet these lower bounds and, hence, have optimal complexity. Finally, we propose probabilistic cluster-sending techniques that only have an expected constant message complexity, this independent of the size of the clusters involved. Depending on the robustness of the clusters involved, these probabilistic techniques require only two-to-four message round-trips while supporting worst-case linear communication between clusters, which is optimal. As such, our work provides a strong foundation for the further development of resilient high-performance systems.</p></blockquote></details></li><li class='ref' id='VLDB-2020 Tutorial'>VLDB 2020 Tutorial. <div class='detail'><quote>Building High Throughput Permissioned Blockchain Fabrics: Challenges and Opportunities</quote>. <span class='author'>Suyash Gupta, Jelle Hellings, Sajjad Rahnama, and Mohammad Sadoghi</span>. <span class='year'>(2020)</span>. <span class='in'>In: Proceedings of the VLDB Endowment, 13(12), 3441-3444</span>. <span class='publisher'>VLDB</span>. <span class='doi'>DOI: <a href='https://doi.org/10.14778/3415478.3415565'>10.14778/3415478.3415565</a></span>. </div><span class='resources'> <a class='acopy' href='files/vldb2020_tutorial.pdf'>author copy</a>, <a class='aslide' href='files/vldb2020_slides.pdf'>slides</a>, <a class='avideo' href='https://www.youtube.com/watch?v=Jj6hVs1SF3E'>video of the entire tutorial</a></span>. <details class='embed'><summary>Video Presentation</summary><div class='iframe-container'><div><iframe title='video-player' src='https://player.vimeo.com/video/586608490/' frameborder='0' allowfullscreen></iframe></div></div></details><details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Since the introduction of Bitcoin--the first widespread application driven by blockchains--the interest in the design of blockchain-based applications has increased tremendously. At the core of these applications are consensus protocols that securely replicate client requests among all replicas, even if some replicas are Byzantine faulty. Unfortunately, these consensus protocols typically have low throughput, and this lack of performance is often cited as the reason for the slow wider adoption of blockchain technology. Consequently, many works focus on designing more efficient consensus protocols to increase throughput of consensus.</p><p>We believe that this focus on consensus protocols only explains part of the story. To investigate this belief, we raise a simple question: <em>Can a well-crafted system using a classical consensus protocol outperform systems using modern protocols?</em> In this tutorial, we answer this question by diving deep into the design of blockchain systems. Further, we take an in-depth look at the theory behind consensus, which can help users select the protocol that best-fits their requirements. Finally, we share our vision of high-throughput blockchain systems that operate at large scales.</p></blockquote></details></li><li class='ref' id='VLDB-2020 Demo'>VLDB 2020 Demo. <div class='detail'><quote>Scalable, resilient, and configurable permissioned blockchain fabric</quote>. <span class='author'>Sajjad Rahnama, Suyash Gupta, Thamir M. Qadah, Jelle Hellings, and Mohammad Sadoghi</span>. <span class='year'>(2020)</span>. <span class='in'>In: Proceedings of the VLDB Endowment, 13(12), 2893-2896</span>. <span class='publisher'>VLDB</span>. <span class='doi'>DOI: <a href='https://doi.org/10.14778/3415478.3415502'>10.14778/3415478.3415502</a></span>. </div><span class='resources'> <a class='acopy' href='files/vldb2020_demo.pdf'>author copy</a>, <a class='avideo' href='https://www.youtube.com/watch?v=By4Ga1Lemm4'>video by Sajjad Rahnama</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>With the advent of Bitcoin, the interest of the database community in blockchain systems has steadily grown. Many existing blockchain applications use blockchains as a platform for monetary transactions, however. We deviate from this philosophy and present <em class='name'>ResilientDB</em>, which can serve in a suite of non-monetary data-processing blockchain applications.  Our <em class='name'>ResilientDB</em> uses state-of-the-art technologies and includes a novel visualization that helps in monitoring the state of the blockchain application.</p></blockquote></details></li><li class='ref' id='DEBS-2020 Tutorial'>DEBS 2020 Tutorial. <div class='detail'><quote>Blockchain consensus unraveled: Virtues and limitations</quote>. <span class='author'>Suyash Gupta, Jelle Hellings, Sajjad Rahnama, and Mohammad Sadoghi</span>. <span class='year'>(2020)</span>. <span class='in'>In: Proceedings of the 14th ACM International Conference on Distributed and Event-Based Systems, 218-221</span>. <span class='publisher'>ACM</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1145/3401025.3404099'>10.1145/3401025.3404099</a></span>. </div><span class='resources'> <a class='acopy' href='files/debs2020_tutorial.pdf'>author copy</a>, <a class='aslide' href='files/debs2020_slides.pdf'>slides</a>, <a class='avideo' href='https://www.youtube.com/watch?v=qU6AjDd11oM'>video</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Since the introduction of Bitcoin--the first wide-spread application driven by blockchains--the interest of the public and private sector in blockchains has skyrocketed. At the core of this interest are the ways in which blockchains can be used to improve data management, e.g., by enabling federated data management via decentralization, resilience against failure and malicious actors via replication and consensus, and strong data provenance via a secured immutable ledger.</p><p>In practice, high-performance blockchains for data management are usually built in permissioned environments in which the participants are vetted and can be identified. In this setting, blockchains are typically powered by Byzantine fault-tolerant consensus protocols. These consensus protocols are used to provide full replication among all honest blockchain participants by enforcing an unique order of processing incoming requests among the participants.</p><p>In this tutorial, we take an in-depth look at Byzantine fault-tolerant consensus. First, we take a look at the theory behind replicated computing and consensus. Then, we delve into how common consensus protocols operate. Finally, we take a look at current developments and briefly look at our vision moving forward.</p></blockquote></details></li><li class='ref' id='Reimagine-2020'>Reimagine 2020. <div class='detail'><quote>An in-depth look of BFT consensus in blockchain: Challenges and opportunities</quote>. <span class='author'>Suyash Gupta, Jelle Hellings, Sajjad Rahnama, and Mohammad Sadoghi</span>. <span class='year'>(2020)</span>. </div><span class='resources'> <a class='aslide' href='files/reimagine2020_slides.pdf'>slides</a></span>. </li><li class='ref' id='FAB-2020'>FAB 2020. <div class='detail'><quote>ResilientDB: Global scale resilient blockchain fabric</quote>. <span class='author'>Suyash Gupta, Sajjad Rahnama, Jelle Hellings and Mohammad Sadoghi</span>. <span class='year'>(2020)</span>. <span class='in'>In: The third International Symposium on Foundations and Applications of Blockchain</span>. </div><span class='resources'> <a class='acopy' href='files/fab2020_abstract.pdf'>abstract</a>, <a class='avideo' href='https://www.youtube.com/watch?v=33k9aFoDtBw'>video by Suyash Gupta</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Recent developments in blockchain technology have inspired innovative new designs in resilient distributed and database systems. At their core, these blockchain applications typically use Byzantine fault-tolerant consensus protocols to maintain a common state across all replicas, even if some replicas are faulty or malicious. Unfortunately, existing consensus protocols are not designed to deal with <em>geo-scale deployments</em> in which many replicas spread across a geographically large area participate in consensus.</p><p>To address this, we present the Geo-Scale Byzantine Fault-Tolerant consensus protocol (<em class='name'>GeoBFT</em>). <em class='name'>GeoBFT</em> is designed for excellent scalability by using a topological-aware grouping of replicas in local clusters, by introducing parallelization of consensus at the local level, and by minimizing communication between clusters. To validate our vision of high-performance geo-scale resilient distributed systems, we implement <em class='name'>GeoBFT</em> in our efficient <em class='name'>ResilientDB</em> permissioned blockchain fabric. We show that <em class='name'>GeoBFT</em> is not only sound and  provides great scalability, but also outperforms state-of-the-art consensus protocols by a factor of six in geo-scale deployments.</p></blockquote></details></li><li class='ref' id='Middleware-2019'>Middleware 2019. <div class='detail'><quote>An in-depth look of BFT consensus in blockchain: Challenges and opportunities</quote>. <span class='author'>Suyash Gupta, Jelle Hellings, Sajjad Rahnama, and Mohammad Sadoghi</span>. <span class='year'>(2019)</span>. <span class='in'>In: Proceedings of the 20th International Middleware Conference--Tutorials, 6-10</span>. <span class='publisher'>ACM</span>. <span class='doi'>DOI: <a href='https://doi.org/10.1145/3366625.3369437'>10.1145/3366625.3369437</a></span>. </div><span class='resources'> <a class='acopy' href='files/mw2019_tutorial.pdf'>author copy</a>, <a class='aslide' href='files/mw2019_slides.pdf'>slides</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>Since the introduction of Bitcoin--the first wide-spread application driven by blockchains--the interest of the public and private sector in blockchains has skyrocketed. At the core of this interest are the ways in which blockchains can be used to improve data management, e.g., by enabling federated data management via decentralization, resilience against failure and malicious actors via replication and consensus, and strong data provenance via a secured immutable ledger.</p><p>In practice, high-performance blockchains for data management are usually built in permissioned environments in which the participants are vetted and can be identified. In this setting, blockchains are typically powered by Byzantine fault-tolerant consensus protocols. These consensus protocols are used to provide full replication among all honest blockchain participants by enforcing an unique order of processing incoming requests among the participants.</p><p>In this tutorial, we take an in-depth look at Byzantine fault-tolerant consensus. First, we take a look at the theory behind replicated computing and consensus. Then, we delve into how common consensus protocols operate. Finally, we take a look at current developments and briefly look at our vision moving forward.</p></blockquote></details></li><li class='ref' id='HPTS-2019'>HPTS 2019. <div class='detail'><quote>Efficient transaction processing in Byzantine fault tolerant environments</quote>. <span class='author'>Suyash Gupta, Jelle Hellings, Thamir Qadah, Sajjad Rahnama, and Mohammad Sadoghi</span>. <span class='year'>(2019)</span>. <span class='in'>In: 18th International Workshop on High Performance Transaction Systems</span>. </div><span class='resources'> <a class='acopy' href='files/htps2019_paper.pdf'>abstract</a>, <a class='avideo' href='https://www.youtube.com/watch?v=33k9aFoDtBw'>video by Suyash Gupta</a></span>. </li><li class='ref' id='DBDBD-2016'>DBDBD 2016. <div class='detail'><quote>Graph query optimization using semi-join rewritings</quote>. <span class='author'>Jelle Hellings</span>. <span class='year'>(2016)</span>. <span class='in'>In: The Dutch-Belgian DataBase Day</span>. <span class='also'>See also <a class='also' href='#CJ-2020'>CJ 2020</a>, <a class='also' href='#DBPL-2017'>DBPL 2017</a>, <a class='also' href='#PhD-thesis'>PhD thesis</a></span>.</div><span class='resources'> <a class='acopy' href='files/dbdbd2016_abstract.pdf'>abstract</a>, <a class='aslide' href='files/dbdbd2016_slides.pdf'>slides</a></span>. </li><li class='ref' id='WOG-2013'>WOG 2013. <div class='detail'><quote>Path querying on graph databases</quote>. <span class='author'>Jelle Hellings</span>. <span class='year'>(2013)</span>. <span class='in'>In: WOG (Wetenschappelijke Onderzoeksgemeenschap/Scientific Research Network) Meeting</span>. </div><span class='resources'> <a class='acopy' href='files/wog2013_abstract_long.pdf'>long abstract</a>, <a class='acopy' href='files/wog2013_abstract_short.txt'>short abstract</a>, <a class='aslide' href='files/wog2013_slides.pdf'>slides</a></span>. </li><li class='ref' id='DBDBD-2011'>DBDBD 2011. <div class='detail'><quote>Efficient external-memory bisimulation on DAGs</quote>. <span class='author'>Jelle Hellings</span>. <span class='year'>(2011)</span>. <span class='in'>In: The Dutch-Belgian DataBase Day</span>. <span class='also'>See also <a class='also' href='#SIGMOD-2012'>SIGMOD 2012</a>, <a class='also' href='#Master-thesis'>Master thesis</a></span>.</div><span class='resources'> <a class='acopy' href='files/dbdbd2011_abstract.pdf'>abstract</a>, <a class='aslide' href='files/dbdbd2011_slides.pdf'>slides</a>, <a class='asite' href='projects/exbisim'>project page</a></span>. </li></ol><h3 id='pthesis'>PhD thesis and Master thesis</h3><ol start='38'><li class='ref' id='PhD-thesis'>PhD thesis. <div class='detail'><quote>On tarski's relation algebra: Querying trees and chains and the semi-join algebra</quote>. <span class='author'>Jelle Hellings</span>. <span class='year'>(2018)</span>. <span class='institute'>Hasselt University and transnational University of Limburg</span>. <span class='asviser'>Adviser: Marc Gyssens</span>. <span class='also'>See also <a class='also' href='#CJ-2020'>CJ 2020</a>, <a class='also' href='#IS-2020'>IS 2020</a>, <a class='also' href='#FoIKS-2018a'>FoIKS 2018a</a>, <a class='also' href='#DBPL-2017'>DBPL 2017</a>, <a class='also' href='#DBDBD-2016'>DBDBD 2016</a>, <a class='also' href='#DBPL-2015'>DBPL 2015</a></span>.</div><span class='resources'> <a class='acopy' href='files/phd_thesis.pdf'>author copy</a>, <a class='athesis' href='https://hdl.handle.net/1942/25932'>thesis</a>, <a class='aslide' href='files/phd_defense_slides.pdf'>slides</a>, <a class='asite' href='projects/bruteforce'>project page</a></span>. <details class='abstract' open><summary>Abstract</summary><blockquote class='abstract'><p>Many practical query languages for graph data are based on fragments of Tarski's relation algebra which, optionally, is augmented with the Kleene-star operator. Examples include <em class='name'>XPath</em>, <em class='name'>SPARQL</em>, the <em class='name'>RPQs</em>, and <em class='name'>GXPath</em>. Because of this central role of (fragments of) the relation algebra, we study two aspects in more detail. Combined, these two studies give a detailed picture of the expressive power of the fragments of the relation algebra. Moreover, our results provide several opportunities for the development of new techniques for the efficient evaluation of graph queries.</p></blockquote></details></li><li class='ref' id='Master-thesis'>Master thesis. <div class='detail'><quote>Bisimulation partitioning and partition maintenance</quote>. <span class='author'>Jelle Hellings</span>. <span class='year'>(2011)</span>. <span class='institute'>Eindhoven University of Technology</span>. <span class='asviser'>Adviser: George H. L. Fletcher</span>. <span class='also'>See also <a class='also' href='#SIGMOD-2012'>SIGMOD 2012</a>, <a class='also' href='#DBDBD-2011'>DBDBD 2011</a></span>.</div><span class='resources'> <a class='acopy' href='files/msc_thesis.pdf'>author copy</a>, <a class='athesis' href='https://research.tue.nl/files/47016023/716798-1.pdf'>thesis</a>, <a class='aslide' href='files/msc_slides_final.pdf'>final slides</a>, <a class='aslide' href='files/msc_slides_midterm.pdf'>mid-term slides</a>, <a class='aposter' href='files/msc_poster_award.pdf'>poster</a>, <a class='asite' href='projects/exbisim'>project page</a></span>. <details class='abstract'><summary>Abstract</summary><blockquote class='abstract'><p>The combination of graphs and node bisimulation is widely used within and outside of computer science. One example of this combination is constructing indices for speeding up queries on <em class='name'>XML</em> documents. Thereby <em class='name'>XML</em> documents can be represented by trees and many index types for indexing <em class='name'>XML</em> documents utilize the notion of bisimulation. Thereby the notion of bisimulation is used to relate nodes that have equivalent behavior with respect to queries performed on the <em class='name'>XML</em> documents. By replacing these bisimilar nodes one can reduce the size of the <em class='name'>XML</em> document and as such speed up queries. The objective of this thesis is to develop techniques for constructing and maintaining bisimulation partitions. Thereby a bisimulation partition groups nodes based on bisimilarity. In this thesis we primarily focus on very large directed acyclic graphs. The results in this thesis can for example be used to index very large <em class='name'>XML</em> documents.</p></blockquote></details></li></ol> -->
</body>
</html>
